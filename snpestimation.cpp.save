#include "snpestimation.h"

SnpEstimation::SnpEstimation(const Command &commander){
    m_thread = commander.getNThread();
    m_ldCorrection = commander.ldCorrect();
    m_extreme = commander.getExtremeAdjust();
    m_prevalence = commander.getPrevalence();
    m_qt = commander.quantitative();
    m_bt = commander.binary();
    m_blockSize = commander.getSizeOfBlock();
    m_output = commander.getOutputPrefix();
}

SnpEstimation::~SnpEstimation()
{
    //dtor
}

void SnpEstimation::estimate(GenotypeFileHandler &genotypeFileHandler,const std::map<std::string, size_t> &snpIndex, boost::ptr_vector<Snp> &snpList, boost::ptr_vector<Region> &regionList){
    // This contains the genotypes from the reference panel, the main container for this function
//    boost::ptr_list<Genotype> genotype;
    boost::ptr_deque<Genotype> genotype;
    // This contains the index of the SNPs included in the genotype
    // Important for everything (otherwise, how do we the beta and update the heritability?)
//    std::list<size_t> snpLoc;
    std::deque<size_t> snpLoc;
    // This should be invoked when we came to the end of chromosome / region
    // Such that the buffed variance can be added back to the total variance
    // Useless when the sign of the statistics is not given
    bool finalizeBuff = false;

    Linkage linkage(m_thread, m_blockSize);
    Decomposition decompose(m_thread);
    fprintf(stderr, "Estimate SNP heritability\n");
    // Ignore the progress bar just yet
    // Only add it in when everything is completed
    /** Progress Bar related code here **/
    // The completed flag should be the return from GenotypeFileHandler. When all the SNPs
    // from the reference panel were used, then the completed flag should change to true
    bool completed = false;
    // This thing is getting advance...
//    std::deque<std::list<size_t>::iterator > boundary;
    std::deque<size_t> boundary;
    //std::deque<size_t> boundary; //The boundary is used to indicate the blocks
    bool starting = true;
    while(!completed){
        // Get the required genotypes
        // The concept now is simpler
        // 1. Get all the required SNPs for the analysis using genotypeFileHandler
        //    - Remove all SNPs that doesn't pass the threshold or QC
        // 2. Perform the LD matrix construction
        // 3. For each window, remove the perfect LD by not including them in the decomposition
        //    - Remember, if they are in perfect LD, we can just move the row around and they will still be the same
//        fprintf(stderr, "Get Block\n");
        bool retainLastBlock=false; // only used when the finalizeBuff is true, this indicate whether if the last block is coming from somewhere new
//        std::cerr << "Conditions: " << boundary.size() << "\t" << completed << "\t" << finalizeBuff <<  std::endl;
        while(boundary.size() < 4 && !completed && !finalizeBuff){
            // We will continue to get block
            // When getBlock return, the iterator are always pointing to the next valid SNP
            // However, it is possible for this SNP to not pass the MAF threshold or are in
            // perfect LD with SNPs in previous blocks. Therefore we need to make sure that
            // when we remove/filter this SNP, the next SNP is still within the acceptable
            // region
            fprintf(stderr, "Get Block now\n");
            genotypeFileHandler.getBlock(snpList, genotype, snpLoc, finalizeBuff, completed,boundary);
            // Now calculate the LD

            bool boundChange = false;
            fprintf(stderr, "Construct\n");
            linkage.construct(genotype, snpLoc, boundary, snpList, m_ldCorrection, boundChange);
            // Three possibilities
            // 1. Boundary intact, then we can continue
            // 2. Boundary changed, but still in range. Read more SNPs and continue
            // 3. Boundary changed, out of range now, start decomposition
            // Here we need to check the boundaries
            bool skip = false;
//            if(boundChange && boundary.back() != snpLoc.end()){
            if(boundChange && boundary.back() != snpLoc.back()){
                // need to check if the blocks are now ok, if not, change finalizeBuff to true
                // Also, need special

            fprintf(stderr, "Change bound\n");
//                size_t lastLoc = *(boundary.back());
                size_t lastLoc = boundary.back();
//                size_t prevLoc = *std::prev(boundary.back());
                size_t prevLoc = boundary.back()-1;
                if(snpList.at(snpLoc[lastLoc]).getLoc()-snpList.at(snpLoc[prevLoc]).getLoc() > m_blockSize){
                    // this is problematic here

                    fprintf(stderr, "man...\n");
                    retainLastBlock = true;
                    finalizeBuff = true;
                }
                else{}// everything as normal

            }
            else if(boundChange){ // this is the abnormal situation where the after removing the perfect LDs, we lost the whole block

            fprintf(stderr, "bound also changed\n");
                finalizeBuff = true;
                boundary.pop_back(); //The last one is just for checking
                skip = true; // don't bother in padding
            }
            else{} //everything as normal
            // now pad the remaining SNPs for the last block
            // then construct the LD and remove the perfectLD again.
            // however, this time, we are certain there will be no boundary change
            if(!skip){

            fprintf(stderr, "Add SNPs\n");
                genotypeFileHandler.getSNP(snpList, genotype, snpLoc, finalizeBuff, completed,boundary);

            for(size_t i = 0; i < boundary.size(); ++i) std::cerr << boundary[i] << " ";
            std::cerr << std::endl;
            for(size_t i = 0; i < snpLoc.size(); ++i) std::cerr << snpLoc[i] << " ";
            std::cerr <<  std::endl;
            fprintf(stderr, "Construct again\n");
                linkage.construct(genotype, snpLoc, boundary, snpList, m_ldCorrection, boundChange);

            fprintf(stderr, "nice and done\n");
            }
        }
        // Need to check if we need to merge the last block into the one in front
        // Only consider it when we reached the end of the current region
        if(finalizeBuff && boundary.size() > 3){
            fprintf(stderr, "Special\n");
//            // Now check if we need to merge the last two blocks
//            size_t lastSnpOfThirdBlock = snpList.at(*std::prev(boundary.back())).getLoc();
            fprintf(stderr, "Bound back is %lu and size is %lu\n", boundary.back(), snpLoc.size());
            size_t lastSnpOfThirdBlock = snpList.at(snpLoc.at(boundary.back())).getLoc();
            size_t lastSnp = snpLoc.back(); //The last of snpLoc is the last of the last block
            lastSnp = snpList.at(lastSnp).getLoc();
            if(lastSnp-lastSnpOfThirdBlock <= m_blockSize){
                boundary.pop_back(); //Because the boundary changed, we should also update the LD matrix
                // Mainly, the top right and bottom left corner
                bool boundChange = false;
                // Can consider writing a more efficient algorithm for this, however, this should also be rare.
                linkage.construct(genotype, snpLoc, boundary, snpList, m_ldCorrection, boundChange);
            }
        }
        // When we reach here, we are ready for decomposition

        linkage.print();
        exit
        fprintf(stderr, "Decomposition\n");
        if(finalizeBuff) decompose.run(linkage, snpLoc, boundary, snpList, finalizeBuff, !retainLastBlock, starting, regionList);
        else decompose.run(linkage, snpLoc, boundary, snpList, false, false, starting, regionList);
        fprintf(stderr, "Finish decompose\n");
        for(size_t i = 0; i < boundary.size(); ++i) std::cerr << boundary[i] << " " ;
        std::cerr << std::endl;
        std::cerr << "SnpLoc: ";
        for(size_t i = 0; i < snpLoc.size(); ++i) std::cerr << snpLoc[i] << " " ;
        std::cerr << std::endl;
        if(finalizeBuff){
            starting = true;
            // We need to check if we are going to store the last block
            if(retainLastBlock){
//                std::cerr << "Retain the last block" << std::endl;

                size_t update = boundary[1]-1; //We want to retain the SNP at the boundary
                genotype.erase(genotype.begin(), genotype.begin()+update);
                snpLoc.erase(snpLoc.begin(), snpLoc.begin()+update);
//                boost::ptr_list<Genotype>::iterator genoIter = genotype.begin();
//                size_t nRemoveElements =std::distance(snpLoc.begin(), boundary[1]);
//                std::advance(genoIter,nRemoveElements);
//                genotype.erase(genotype.begin(), genoIter);
//                snpLoc.erase(snpLoc.begin(), boundary[1]);
                boundary.pop_front();
                size_t boundSize = boundary.size();
                for(size_t i = 0; i < boundSize; ++i) boundary[i]-= (update+1);
                linkage.clear(update);
            }
            else{
//                std::cerr << "Exterminate!!!" << std::endl;
                //clean everything
                snpLoc.clear();
                boundary.clear();
                genotype.clear();
                linkage.clear();
            }
            finalizeBuff = false;
        }
        else{
//            std::cerr << "Cleaning lady" << std::endl;
            starting = false;
            size_t update = boundary[1]-1;
            genotype.erase(genotype.begin(), genotype.begin()+update);
            snpLoc.erase(snpLoc.begin(), snpLoc.begin()+update);
            //Also clean everything except the last block
//            boost::ptr_list<Genotype>::iterator genoIter = genotype.begin();
//            size_t nRemoveElements =std::distance(snpLoc.begin(), boundary[1]);
//            std::advance(genoIter,nRemoveElements);
//            genotype.erase(genotype.begin(), genoIter);
//            snpLoc.erase(snpLoc.begin(), boundary[1]);
            boundary.pop_front();
            size_t boundSize = boundary.size();
            for(size_t i = 0; i < boundSize; ++i) boundary[i]-= (update+1);
            linkage.clear(update);

        }
//        fprintf(stderr, "Next round\n");
//        std::cerr << "Completed? " << completed << std::endl;

    }
    fprintf(stderr, "Estimated the SNP Heritability, now proceed to output\n");
}



void SnpEstimation::result(const boost::ptr_vector<Snp> &snpList, const boost::ptr_vector<Region> &regionList){

    double i2 = (m_bt)? usefulTools::dnorm(usefulTools::qnorm(m_prevalence))/(m_prevalence): 0;
    i2 = i2*i2;
    double adjust = 0.0;
    size_t count  = 0;
    double sampleSize = 0.0;
    std::vector<double> heritability;
    std::vector<double> variance;
    std::vector<double> effective;
    for(size_t i = 0; i < regionList.size(); ++i){
        // add stuff
        heritability.push_back(0.0);
        variance.push_back(regionList[i].getVariance());
        effective.push_back(0.0);
    }
    std::ofstream fullOutput;
    bool requireFullOut = false;
    if(!m_output.empty()) requireFullOut = true;
    if(requireFullOut){
        std::string fullOutName = m_output;
        fullOutName.append(".res");
        fullOutput.open(fullOutName.c_str());
        if(!fullOutput.is_open()){
            requireFullOut = false;
            fprintf(stderr, "Cannot access output file: %s\n", fullOutName.c_str());
            fprintf(stderr, "Will only provide basic output\n");
        }
        else{
            fullOutput << "Chr\tLoc\trsID\tZ\tH\tStatus" << std::endl;
        }
    }
    for(size_t i = 0; i < snpList.size(); ++i){
        if(requireFullOut){
            fullOutput << snpList[i].getChr() << "\t" << snpList[i].getLoc() << "\t" << snpList[i].getRs() << "\t" << snpList[i].getStat() << "\t" << snpList[i].getHeritability() << "\t" << snpList[i].getStatus() << std::endl;
        }
        for(size_t j = 0; j < regionList.size(); ++j){
//            if(j ==0) std::cerr << snpList[i].flag(j) << std::endl;
            if(snpList[i].flag(j)) heritability[j]+=snpList[i].getHeritability();
            if(snpList[i].flag(j)) effective[j] += snpList[i].getEffective();
        }
        sampleSize +=(double)(snpList[i].getSampleSize());
        count++;
        if(m_bt){
            double portionCase = (double)(snpList[i].getNCase()) / (double)(snpList[i].getSampleSize());
            adjust+= ((1.0-m_prevalence)*(1.0-m_prevalence))/(i2*portionCase*(1-portionCase));
        }

    }

    if(requireFullOut) fullOutput.close();

    double adjustment = adjust/(double)count; // we use the average adjustment value here
    if(!m_bt) adjustment = m_extreme;
    double averageSampleSize = sampleSize/(double)count;
//    std::cerr << "Adjustment is: " << adjustment << std::endl;
    if(!m_output.empty()) requireFullOut =true;
    std::ofstream sumOut;
    if(requireFullOut){
        std::string sumOutName = m_output;
        sumOutName.append(".sum");
        sumOut.open(sumOutName.c_str());
        if(!sumOut.is_open()){
            fprintf(stderr, "Cannot access output file %s\n", sumOutName.c_str());
            fprintf(stderr, "Will output to stdout instead\n");
            requireFullOut=false;
        }
    }
    if(!requireFullOut){
        // Only output to the stdout
        std::cout << "Region\tHeritability\tVariance" << std::endl;
        for(size_t i = 0; i < regionList.size(); ++i){
            std::cout << regionList[i].getName() << "\t" << adjustment*heritability[i] << "\t";

            if(variance[i]==0.0){ // We use effective number
                std::cout << adjustment*(2.0*(effective[i]*adjustment*adjustment+2.0*adjustment*effective[i]*averageSampleSize)/(averageSampleSize*averageSampleSize)) << std::endl;
            }
            else{
                std::cout << adjustment*adjustment*variance[i] << std::endl;
            }
        }
    }
    else{
        sumOut << "Region\tHeritability\tVariance" << std::endl;
        std::cout << "Region\tHeritability\tVariance" << std::endl;
        for(size_t i = 0; i < regionList.size(); ++i){
            sumOut << regionList[i].getName() << "\t" << adjustment*heritability[i] << "\t";
            std::cout << regionList[i].getName() << "\t" << adjustment*heritability[i] << "\t";

            if(variance[i]==0.0){ // We use effective number
                sumOut << adjustment*(2.0*(effective[i]*adjustment*adjustment+2.0*adjustment*effective[i]*averageSampleSize)/(averageSampleSize*averageSampleSize)) << std::endl;
                std::cout << adjustment*(2.0*(effective[i]*adjustment*adjustment+2.0*adjustment*effective[i]*averageSampleSize)/(averageSampleSize*averageSampleSize)) << std::endl;
            }
            else{
                sumOut << adjustment*adjustment*variance[i] << std::endl;
                std::cout << adjustment*adjustment*variance[i] << std::endl;
            }
        }
        sumOut.close();
    }
}
